---
classes:
  java.util.Vector<E>:
    dev_mode: false
    doc_string: |
      \brief Implementation of java.util.Vector.
      \details This class functions the same as ArrayList.
      \attention
      While java.util.Vector is thread-safe in java,
      this is not the case in C++.
    fields:
      capacityIncrement:
        omit: true
        encoder_expr: "0"
      elementCount:
        omit: true
      elementData:
        omit: true
      data_:
        visibility: private
        type:
          cxx: ::std::vector<$boundTemplateType(java.("E"), "style=type, class=field")$, ::cycle_ptr::cycle_allocator<::std::allocator<$boundTemplateType(java.("E"), "style=type, class=field")$>>>
          includes:
            declaration:
            - vector
            - cycle_ptr/allocator.h
        default: ::cycle_ptr::cycle_allocator<::std::allocator<$boundTemplateType(java.("E"), "style=type, class=field")$>>(*this)
    members:
    - type: constructor
    - type: constructor
      arguments:
      - name: b
        type:
          cxx: ::java::forward_iterator<$boundTemplateType(java.("E"), "style=type")$>
          includes:
            declaration:
            - java/iterator.h
      - name: e
        type:
          cxx: ::java::forward_iterator<$boundTemplateType(java.("E"), "style=type")$>
          includes:
            declaration:
            - java/iterator.h
      initializers:
        data_: std::move(b), std::move(e), ::cycle_ptr::cycle_allocator<::std::allocator<$boundTemplateType(java.("E"), "style=type, class=field")$>>(*this)
    - type: constructor
      arguments:
      - name: init
        type:
          cxx: ::std::initializer_list<$boundTemplateType(java.("E"), "style=type, class")$>
          includes:
            declaration:
            - initializer_list
      initializers:
        data_: init.begin(), init.end(), ::cycle_ptr::cycle_allocator<::std::allocator<$boundTemplateType(java.("E"), "style=type, class=field")$>>(*this)
    - type: constructor
      arguments:
      - name: init
        type:
          java: java.lang.Iterable<? extends E>
      initializers:
        data_: init->begin(), init->end(), ::cycle_ptr::cycle_allocator<::std::allocator<$boundTemplateType(java.("E"), "style=type, class=field")$>>(*this)
    - type: method
      name: empty
      override: true
      const: true
      noexcept: true
      covariant_return: false
      return:
        cxx: bool
      body: |
        return data_.empty();
    - type: method
      name: size
      override: true
      const: true
      noexcept: true
      covariant_return: false
      return:
        cxx: ::std::size_t
        includes:
          declaration:
          - cstddef
      body: |
        return data_.size();
    - type: method
      name: push_front
      override: true
      return:
        cxx: bool
      arguments:
      - name: e
        type:
          java: E
      body: |
        data_.insert(data_.begin(), std::move(e));
        return true;
    - type: method
      name: push_back
      override: true
      return:
        cxx: bool
      arguments:
      - name: e
        type:
          java: E
      body: |
        data_.push_back(std::move(e));
        return true;
    - type: method
      name: pop_back
      override: true
      return:
        java: E
      body: |
        $boundTemplateType(java.("E"), "style=type, class")$ r = std::move(data_.back());
        data_.pop_back();
        return r;
    - type: method
      name: pop_front
      override: true
      return:
        java: E
      body: |
        $boundTemplateType(java.("E"), "style=type, class")$ r = std::move(data_.front());
        data_.erase(data_.begin());
        return r;
    - type: method
      name: clear
      override: true
      body: |
        data_.clear();
    - type: method
      name: begin
      override: true
      return:
        cxx: ::java::bidirectional_iterator<$boundTemplateType(java.("E"), "style=type")$>
        includes:
          declaration:
          - java/iterator.h
      body: |
        return ::java::bidirectional_iterator<$boundTemplateType(java.("E"), "style=type")$>(data_.begin());
    - type: method
      name: end
      override: true
      return:
        cxx: ::java::bidirectional_iterator<$boundTemplateType(java.("E"), "style=type")$>
        includes:
          declaration:
          - java/iterator.h
      body: |
        return ::java::bidirectional_iterator<$boundTemplateType(java.("E"), "style=type")$>(data_.end());
    - type: method
      name: begin
      const: true
      override: true
      return:
        cxx: ::java::bidirectional_iterator<const $boundTemplateType(java.("E"), "style=type")$>
        includes:
          declaration:
          - java/iterator.h
      body: |
        return ::java::bidirectional_iterator<const $boundTemplateType(java.("E"), "style=type")$>(data_.begin());
    - type: method
      name: end
      const: true
      override: true
      return:
        cxx: ::java::bidirectional_iterator<const $boundTemplateType(java.("E"), "style=type")$>
        includes:
          declaration:
          - java/iterator.h
      body: |
        return ::java::bidirectional_iterator<const $boundTemplateType(java.("E"), "style=type")$>(data_.end());
    - type: method
      name: front
      override: true
      const: true
      return:
        java: const E
      body: |
        return data_.front();
    - type: method
      name: back
      override: true
      const: true
      return:
        java: const E
      body: |
        return data_.back();
    - type: method
      name: front
      override: true
      return:
        java: E
      body: |
        return data_.front();
    - type: method
      name: back
      override: true
      return:
        java: E
      body: |
        return data_.back();
    - type: method
      name: at
      override: true
      arguments:
      - name: index
        type:
          cxx: ::std::size_t
          includes:
            declaration:
            - cstddef
      return:
        java: E
      body: |
        return data_.at(index);
    - type: method
      name: at
      const: true
      override: true
      arguments:
      - name: index
        type:
          cxx: ::std::size_t
          includes:
            declaration:
            - cstddef
      return:
        java: const E
      body: |
        return data_.at(index);
    - type: method
      name: __decoder_annotation__
      visibility: private
      arguments:
      - name: decoder
        type:
          cxx: const ::java::serialization::class_decoder<$tagType(model)$>&
          includes:
            declaration:
            - java/serialization/decoder_fwd.h
            implementation:
            - java/serialization/decoder.h
      body: |
        using namespace ::std::string_view_literals;

        auto len = decoder.get_primitive_field<$boundTemplateType(java.({int}), "style=type, class")$>($u16StringView("elementCount")$);
        if (len < 0) throw ::java::serialization::decoding_error($cxxString({$model.name$: negative collection size})$);

        auto elementData = decoder.get_complete_field<$boundTemplateType(java.({java.lang.Object[]}), "style=type, class")$>($u16StringView("elementData")$);

        data_.reserve(len);
        for (auto i : elementData)
          data_.emplace_back(std::move(i));
      includes:
        implementation:
        - algorithm
        - iterator
        - string_view
    - type: method
      name: __encoder_annotation__
      visibility: private
      const: true
      arguments:
      - name: handler_
        type:
          cxx: ::java::serialization::cycle_handler&
          includes:
            declaration:
            - java/serialization/type_def_fwd.h
      - name: fields
        type:
          cxx: ::java::serialization::stream::new_object::class_data::field_map&
          includes:
            declaration:
            - java/serialization/encdec.h
      return:
        cxx: ::std::vector<::std::variant<::cycle_ptr::cycle_gptr<const ::java::serialization::stream::stream_element>, ::java::serialization::stream::blockdata>>
        includes:
          declaration:
          - vector
          - cycle_ptr/cycle_ptr.h
          - java/serialization/type_def_fwd.h
          implementation:
          - java/serialization/encdec.h
      body: |
        using namespace ::std::string_view_literals;
        using namespace ::java::serialization::stream;

        if (data_.size() > 0x7fffffffu)
          throw ::std::logic_error($cxxString({$model.name$: size too large})$);

        auto elementData = $boundTemplateType(java.({java.lang.Object[]}), "style=type, class")$(::java::allocate);
        elementData.reserve(data_.size());
        for (const auto& i : data_)
          elementData.push_back(::java::constcast<::java::lang::Object>(i));

        new_object::class_data::set_field(
            fields,
            $u16StringView("elementCount")$,
            primitive_desc::value_type(::std::in_place_type<$boundTemplateType(java.({int}), "style=type, class")$>, data_.size()));
        new_object::class_data::set_field(
            fields,
            $u16StringView("elementData")$,
            object_desc::value_type(handler_.encode_field(std::move(elementData))));

        return {};
      includes:
        implementation:
        - stdexcept
        - variant
