fwdHeaderFile(codeGen, includes) ::= <<
#ifndef JAVA_FWD_$codeGen.includeGuard$
#define JAVA_FWD_$codeGen.includeGuard$

///\file
///\brief Forward declarations for $codeGen.baseType; separator = "."$
///\note Include <$codeGen.headerName$> instead.

#include <cstddef>
#include <java/_accessor.h>
#include <java/ref.h>
#include <java/inline.h>

// Forward declare all erased types.
namespace $["java", "_erased", codeGen.namespace]; separator = "::"$ {

$codeGen.types:{model|class $model.className$;}; separator = "\n"$

} /* namespace $["java", "_erased", codeGen.namespace]; separator = "::"$ */

// Declare all tags.
namespace $["java", "_tags", codeGen.namespace]; separator = "::"$ {

$codeGen.types:{model|$tagDeclaration(model)$}; separator = "\n\n"$

} /* namespace $["java", "_tags", codeGen.namespace]; separator = "::"$ */

// Forward declare accessors.
namespace java {

$codeGen.accessors:{accessorModel|$forwardDeclareAccessor(accessorModel)$; // Forward declaration.}; separator = "\n\n"$

} /* namespace java */

$if (codeGen.namespace)$
namespace $codeGen.namespace; separator = "::"$ {

$endif$
$codeGen.types:{model|$declareBasicRef(model)$}; separator = "\n"$
$if (codeGen.namespace)$

} /* namespace $codeGen.namespace; separator = "::"$ */
$endif$

$includes:{f|$include(f)$}; separator = "\n"$

// render accessors
namespace java {

$codeGen.accessors:{accessorModel|$accessor(accessorModel)$}; separator = "\n\n"$

} /* namespace java */

#endif /* JAVA_FWD_$codeGen.includeGuard$ */

>>


headerFile(codeGen, includes) ::= <<
#ifndef $codeGen.includeGuard$
#define $codeGen.includeGuard$

$include(codeGen.fwdHeaderName)$

///\file
///\brief Code for $codeGen.baseType; separator = "."$

$includes:{f|$include(f)$}; separator = "\n"$

// render erased types
namespace $["java", "_erased", codeGen.namespace]; separator = "::"$ {

$codeGen.reorderTypesForInheritance:{model|$class(model)$}; separator = "\n\n"$

} /* namespace $["java", "_erased", codeGen.namespace]; separator = "::"$ */

// render accessors
namespace java {

$codeGen.accessors:{accessorModel|$accessorImpl(accessorModel)$}; separator = "\n\n"$

} /* namespace java */

// Render inline class members.
namespace $["java", "_erased", codeGen.namespace]; separator = "::"$ {

$codeGen.types:{model|$classHeaderImpl(model)$}; separator = "\n\n"$

} /* namespace $["java", "_erased", codeGen.namespace]; separator = "::"$ */

#endif /* $codeGen.includeGuard$ */

>>


srcFile(codeGen, includes) ::= <<
$codeGen.types: {t|$t.srcRaw$}; separator="\n"$
$[codeGen.headerName, includes]:{f|$include(f)$}; separator = "\n"$

namespace $["java", "_erased", codeGen.namespace]; separator = "::"$ {

$codeGen.types:emitStaticCompileChecks(); separator = "\n"$

$codeGen.types:{model|$classImpl(model)$}; separator = "\n\n"$

} /* namespace $["java", "_erased", codeGen.namespace]; separator = "::"$ */

namespace java {

$codeGen.accessors:{accessorModel|$accessorImplSrc(accessorModel)$}; separator = "\n\n"$

} /* namespace java */

>>


moduleHeader(name, headers, types) ::= <<
$include({java/serialization/module.h})$

namespace java::modules {
auto $name$() -> const ::java::serialization::module&;
} /* namespace java::modules */
>>


moduleSource(name, headers, types) ::= <<
$include({java/modules/$name$.h})$
$include({string_view})$
$include({java/reflect.h})$

$ headers
: include()
; separator = "\n"$

namespace java::modules {

auto $name$()
-> const ::java::serialization::module& {
  using namespace ::std::string_view_literals;

  static const auto impl = ::java::serialization::module({
      $ types
      : { model | { $u16StringView(model.name)$,$"\n"$$\\$
                  $"  "${ ::java::serialization::module::__class__<$erasedType(model)$>(),$"\n"$$\\$
                  $"    "$$if (!model.interface && !model.abstract && model.testInherits.({java.io.Serializable}))$::java::serialization::module::__decoder__<$erasedType(model)$>()$else$nullptr$endif$$"\n"$$\\$
                  $"  "$\}\}}
      ; anchor, separator = ",\n"$
      });

  return impl;
}

} /* namespace java::modules */
>>


tagDeclaration(model) ::= <<
struct $model.className$ {
  static constexpr ::std::size_t generics_arity = $length(model.templateArguments)$;
  using erased_type = ::$["java", "_erased", model.namespace, model.className]; separator = "::"$;

  static constexpr ::std::u16string_view u_name() {
    using namespace ::std::string_view_literals;

    return $u16StringView(model.name)$;
  }
};
>>


forwardDeclareAccessor(accessorModel) ::= <<
template<$["Base_", accessorModel.model.templateArgumentNames]:{x|typename $x$}; anchor, wrap, separator = ", "$>
class _accessor<$["Base_", tagType(accessorModel.model), accessorModel.model.templateArgumentNames]; anchor, wrap, separator = ", "$>
>>


declareBasicRef(model) ::= <<
$renderDocString(model.docString)$
$if (model.templateArgumentNames)$
template<$model.templateArgumentNames:{x|typename $x$}; anchor, wrap, separator = ", "$>
$endif$
using $model.className$ = ::java::type<$[{::$["java", "_tags", model.namespace, model.className]; separator = "::"$}, model.templateArgumentNames]:{x|$x$}; anchor, wrap, separator = ", "$>;
>>


emitStaticCompileChecks(model) ::= <<
$if (model.devMode)$#if 0 // Development mode, checks disabled.$endif$
$if (model.abstract)$
static_assert(::std::is_abstract_v<$model.className$>, "Abstract class must be abstract.");
$elseif (model.interface)$
static_assert(::std::is_abstract_v<$model.className$>, "Interface must be abstract.");
$else$
static_assert(${::std::negation_v<::std::is_abstract<$model.className$\>>}$, "Class (that is neither an interface, nor abstract) may not be abstract.");
$endif$
$if (model.devMode)$#endif$endif$
>>


include(file) ::= <<
#include <$file$>
>>