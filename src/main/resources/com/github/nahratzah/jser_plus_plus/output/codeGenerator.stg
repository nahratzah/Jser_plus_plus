accessor(cdef) ::= <<
$templateLine(cdef.templateArguments, true)$
class _static_accessor$templateArgs([cdef.tagName, cdef.templateArguments], true)$ {
 protected:
  JSER_INLINE _static_accessor() = default;
  JSER_INLINE _static_accessor(const _static_accessor&) = default;
  JSER_INLINE _static_accessor(_static_accessor&&) = default;
  JSER_INLINE _static_accessor& operator=(const _static_accessor&) = default;
  JSER_INLINE _static_accessor& operator=(_static_accessor&&) = default;
  JSER_INLINE ~_static_accessor() = default;

 public:
$if (cdef.model.enum)$
  /**
   * \brief Raw enum constants for $[cdef.namespace, cdef.className]; separator = "."$
   * \note Enums start with upper case, followed by lower case, to avoid name clashes with defines.
   */
  enum class enum_t {
    $cdef.model.enumValues:{kv|$kv.remappedName$}; anchor, separator = ",\n"$
  };

  // Enum constants.
  $cdef.model.enumValues:{kv | $accessorEnumConstantMethodDeclaration(cdef, kv)$}; anchor, separator = "\n"$
$endif$
};

$templateLine(["Base_", cdef.templateArguments], true)$
class _accessor$templateArgs(["Base_", cdef.tagName, cdef.templateArguments], true)$
: public virtual Base_
{
 protected:
  JSER_INLINE _accessor() = default;
  JSER_INLINE _accessor(const _accessor&) = default;
  JSER_INLINE _accessor(_accessor&&) = default;
  _accessor& operator=(const _accessor&) = delete;
  _accessor& operator=(_accessor&&) = delete;
  JSER_INLINE ~_accessor() = default;

 public:
$if (cdef.model.fields)$
  // field accessors
  $cdef.model.fields:{f|$fieldAccessors(f)$}; anchor, separator = "\n"$
$endif$

#if 0
  $cdef.model.classMembers; anchor, separator = "\n\n"$
#endif
};
$if (cdef.model.enum)$

$function(
    name="to_string",
    doImplement=false,
    noexcept="noexcept",
    return="std::string_view",
    argumentTypes=[{::java::_static_accessor$templateArgs([cdef.tagName], true)$::enum_t}],
    argumentNames=["enum_value"])$
$endif$
>>


class(cdef) ::= <<
class $cdef.className$$if (cdef.model.final)$ final$endif$
$classInheritance(cdef.model)$
{
$if (cdef.model.enum)$
  $cdef.className$() = delete; // Enum types are not default constructible.
  $cdef.className$(const $cdef.className$&) = delete;
  $cdef.className$($cdef.className$&&) = delete;
  $cdef.className$& operator=(const $cdef.className$&) = delete;
  $cdef.className$& operator=($cdef.className$&&) = delete;

 public:
  using enum_t = ::java::_static_accessor<$cdef.tagName$>::enum_t;

  $cdef.model.enumValues:{kv| $classEnumConstantMethodDeclaration(cdef, kv)$}; anchor, separator = "\n"$

  // We don't want this to be public, but without it, we're having a hard time
  // instantiating the enum class.
  JSER_INLINE $cdef.className$(enum_t enum_value) : value(enum_value) {}
$endif$

 public:
  $if (!cdef.model.enum)$
  $cdef.className$();
  $cdef.className$(const $cdef.className$&);
  $cdef.className$($cdef.className$&&);
  JSER_INLINE $cdef.className$& operator=(const $cdef.className$&) = default;
  JSER_INLINE $cdef.className$& operator=($cdef.className$&&) = default;
  $endif$
  ~$cdef.className$() noexcept override$if (cdef.model.interface || cdef.model.abstract)$ = 0$endif$;

  // XXX constructors that take arguments.

  // XXX methods
$if(cdef.model.fields)$

  // fields
  $cdef.model.fields:{f|$f.visibility$: $field(f)$;}; anchor, separator = "\n"$
$endif$
$if (cdef.model.enum)$

 public:
  ///\brief Value for the enumerator type.
  const enum_t value;
$endif$
};
>>


accessorImpl(cdef) ::= <<
$if (cdef.model.enum)$
$cdef.model.enumValues:{kv | $accessorEnumConstantMethod(cdef, kv)$}; anchor, separator = "\n"$
$endif$

$cdef.model.fields:{f|$fieldAccessorsImpl(cdef, f)$}; separator = "\n"$
>>


accessorImplSrc(cdef) ::= <%
$if (cdef.model.enum)$
$function(
    name="to_string",
    doImplement=true,
    noexcept="noexcept",
    return="std::string_view",
    argumentTypes=[{::java::_static_accessor$templateArgs([cdef.tagName], true)$::enum_t}],
    argumentNames=["enum_value"],
    body={$accessorImplSrcBody(cdef)$})$
$endif$
%>


accessorImplSrcBody(cdef) ::= <<
using enum_t = ::java::_static_accessor$templateArgs([cdef.tagName], true)$::enum_t;
using namespace std::string_view_literals;

switch (enum_value) {
$ cdef.model.enumValues
  : { v |
case enum_t::$v.remappedName$:
  return $u8StringView(v.name)$;$\\$
    }
  ; anchor, separator = "\n"$
}
>>


classImpl(cdef) ::= <<
$if (!cdef.model.enum)$
$cdef.className$::$cdef.className$() = default;
$cdef.className$::$cdef.className$(const $cdef.className$&) = default;
$cdef.className$::$cdef.className$($cdef.className$&&) = default;
$endif$
$cdef.className$::~$cdef.className$() noexcept = default;

$cdef.model.enumValues:{ kv | $classEnumConstantMethod(cdef, kv)$}; separator = "\n"$
>>


field(f) ::= <%
$if (!f.varType.primitive)$$if (f.final)$const $endif$::java::field_t<$endif$
$fieldType(f.varType)$
$if (!f.varType.primitive)$>$endif$
$" "$
$f.name$
%>


fieldAccessors(f) ::= <<
$if (f.getterFn)$$fieldGetter(f)$;$else$// No getter for $f.name$$endif$
$if (f.setterFn)$$fieldSetter(f)$;$else$// No setter for $f.name$$endif$
>>


fieldAccessorsImpl(cdef, f) ::= <<
$if (f.getterFn)$$fieldGetterImpl(cdef, f)$$endif$
$if (f.setterFn)$$fieldSetterImpl(cdef, f)$$endif$
>>


fieldGetter(f) ::= <%
auto $f.name$() const ->
$" "$
$if (!f.varType.primitive)$::java::return_t<$endif$
$fieldType(f.varType)$
$if (!f.varType.primitive)$>$endif$
%>


fieldSetter(f) ::= <%
auto $f.name$(
$if (!f.varType.primitive)$::java::param_t<$endif$
$fieldType(f.varType)$
$if (!f.varType.primitive)$>$endif$
$" "$
value) ->
$" "$
$if (!f.varType.primitive)$::java::return_t<$endif$
$fieldType(f.varType)$
$if (!f.varType.primitive)$>$endif$
%>


fieldGetterImpl(cdef, f) ::= <<
template<$["Base_", cdef.templateArguments]:{x|typename $x$}; separator = ", "$>
JSER_INLINE auto _accessor<$["Base_", cdef.tagName, cdef.templateArguments]; separator = ", "$>::$f.name$() const
-> $if (!f.varType.primitive)$::java::return_t<$endif$$fieldType(f.varType)$$if (!f.varType.primitive)$>$endif$ {
  return this->template ref_<typename $cdef.tagName$::erased_type>().$f.name$;
}
>>


fieldSetterImpl(cdef, f) ::= <<
template<$["Base_", cdef.templateArguments]:{x|typename $x$}; separator = ", "$>
JSER_INLINE auto _accessor<$["Base_", cdef.tagName, cdef.templateArguments]; separator = ", "$>::$f.name$($if (!f.varType.primitive)$::java::param_t<$endif$$fieldType(f.varType)$$if (!f.varType.primitive)$>$endif$ value)
-> $if (!f.varType.primitive)$::java::return_t<$endif$$fieldType(f.varType)$$if (!f.varType.primitive)$>$endif$ {
$if (f.varType.primitive)$
  return ::std::exchange(this->template ref_<typename $cdef.tagName$::erased_type>().$f.name$, value);
$else$
  ::java::return_t<$fieldType(f.varType)$> result = ::std::move(this->template ref_<typename $cdef.tagName$::erased_type>().$f.name$);
  this->template ref_<typename $cdef.tagName$::erased_type>().$f.name$ = ::std::move(value);
  return result;
$endif$
}
>>


fieldType(t) ::= <%
$template(t,
    {$\\$
      ::$[t.type.namespace, t.type.simpleName]; separator = "::"$$\\$
      $if (t.bindings)$<$t.bindings:{b | $fieldType(b)$}; separator = ", "$>$endif$$\\$
    },
    {$\\$
      $t.name$$\\$
    },
    {$\\$
      ::java::array_type<$fieldType(t.type)$, $t.extents$>$\\$
    },
    {$\\$
      ::java::type<::java::G::pack<$[
          {$t.superTypes:{st|::java::G::super<$fieldType(st)$>}; separator = ", "$},
          {$t.extendTypes:{st|::java::G::extends<$fieldType(st)$>}; separator = ", "$}
        ]; separator = ", "$>>
    })$
%>


classInheritance(model) ::= <%
$if (strip([model.superClass, model.interfaces]))$
: $ strip([model.superClass, model.interfaces])
    : {t|$template(
            t=t,
            classRenderer={$classInheritTemplateClassRenderer(t.type)$},
            varRenderer={/* Can't inherit from 'var' */},
            arrayRenderer={/* Can't inherit from 'array' */},
            anyRenderer={/* Can't inherit from 'any' */}
          )$}
    ; anchor, separator = ",\n"
  $
$elseif (!model.isInterface)$
$! Special consideration for java.lang.Object !$
: $["public ::cycle_ptr::cycle_base", "public virtual ::java::object_intf"]; anchor, separator = ",\n"$
$else$
$! Interfaces need to have ::java::object_intf as a base, so if they don't
 ! derive from an interface, declare the interface now.
 !$
: public virtual ::java::object_intf
$endif$
%>


accessorEnumConstantMethodDeclaration(cdef, kv) ::= <<
///\brief Enum constant $kv.name$.
static auto $kv.remappedName$()
-> ::$[cdef.namespace, cdef.className]; separator = "::"$;
>>


accessorEnumConstantMethod(cdef, kv) ::= <<
$if (cdef.templateArguments)$
template<$[cdef.templateArguments]:{x|typename $x$}; separator = ", "$>
$endif$
JSER_INLINE auto _static_accessor<$[cdef.tagName, cdef.templateArguments]; separator = ", "$>::$kv.remappedName$()
-> ::$[cdef.namespace, cdef.className]; separator = "::"$ {
  return ::$[cdef.namespace, cdef.className]; separator = "::"$(
      ::java::_direct(),
      $["java", "_erased", cdef.namespace, cdef.className, kv.remappedName]; separator = "::"$());
}
>>


classEnumConstantMethodDeclaration(cdef, kv) ::= <<
///\brief Enum constant $kv.name$.
static auto $kv.remappedName$()
-> cycle_ptr::cycle_gptr<$cdef.className$>;
>>


classEnumConstantMethod(cdef, kv) ::= <<
auto $cdef.className$::$kv.remappedName$()
-> cycle_ptr::cycle_gptr<$cdef.className$> {
  static const cycle_ptr::cycle_gptr<$cdef.className$> impl =
      cycle_ptr::make_cycle<$cdef.className$>($cdef.className$::enum_t::$kv.remappedName$);
  return impl;
}
>>


classInheritTemplateClassRenderer(model) ::= <%
$if (model.interface)$public virtual$else$public$endif$ ::$["java", "_erased", model.namespace, model.simpleName]; separator = "::"$
%>


template(t, classRenderer, varRenderer, arrayRenderer, anyRenderer) ::= <%
$(t.templateStyle)(classRenderer, varRenderer, arrayRenderer, anyRenderer)$
%>


templateClass(classRenderer, varRenderer, arrayRenderer, anyRenderer) ::= <%$classRenderer$%>
templateVar(classRenderer, varRenderer, arrayRenderer, anyRenderer) ::= <%$varRenderer$%>
templateArray(classRenderer, varRenderer, arrayRenderer, anyRenderer) ::= <%$arrayRenderer$%>
templateAny(classRenderer, varRenderer, arrayRenderer, anyRenderer) ::= <%$anyRenderer$%>
