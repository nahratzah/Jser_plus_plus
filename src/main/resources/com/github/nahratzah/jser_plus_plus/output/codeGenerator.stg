accessor(model) ::= <<
$templateLine(model.templateArgumentNames, true)$
class _static_accessor$templateArgs([tagType(model), model.templateArgumentNames], true)$ {
 protected:
  JSER_INLINE _static_accessor() = default;
  JSER_INLINE _static_accessor(const _static_accessor&) = default;
  JSER_INLINE _static_accessor(_static_accessor&&) = default;
  JSER_INLINE _static_accessor& operator=(const _static_accessor&) = default;
  JSER_INLINE _static_accessor& operator=(_static_accessor&&) = default;
  JSER_INLINE ~_static_accessor() = default;

 public:
$if (model.enum)$
  /**
   * \brief Raw enum constants for $[model.namespace, model.className]; separator = "."$
   * \note Enums start with upper case, followed by lower case, to avoid name clashes with defines.
   */
  enum class enum_t : ::java::int_t {
    $model.enumValues:{kv|$kv.remappedName$}; anchor, separator = ",\n"$
  };
$endif$

  $staticAccessorClassMembers(model, false); anchor$
};

$templateLine(["Base_", model.templateArgumentNames], true)$
class _accessor$templateArgs(["Base_", tagType(model), model.templateArgumentNames], true)$
$accessorInheritance(model, "Base_")$
{
 protected:
  JSER_INLINE _accessor() = default;
  JSER_INLINE _accessor(const _accessor&) = default;
  JSER_INLINE _accessor(_accessor&&) = default;
  _accessor& operator=(const _accessor&) = delete;
  _accessor& operator=(_accessor&&) = delete;
  JSER_INLINE ~_accessor() = default;

 public:
$if (model.fields)$
  // field accessors
  $model.fields:{f|$fieldAccessors(model, f, false)$}; anchor, separator = "\n"$
$endif$

  $accessorClassMembers(model, false); anchor$
};
$if (model.enum)$

$accessorEnumToString(model, false)$
$endif$
>>


class(model) ::= <<
$renderDocString(model.docString)$
class $model.className$$if (model.final)$ final$endif$
$classInheritance(model)$
{
$if (model.friends)$
  $ model.friends
    : {f| $if (f.unresolvedTemplateNames)$$templateLine(f.unresolvedTemplateNames)$$"\n"$$endif$friend $boundTemplateType(f, "style=erased")$;}$

$endif$
$if (model.enum)$
  $model.className$() = delete; // Enum types are not default constructible.
  $model.className$(const $model.className$&) = delete;
  $model.className$($model.className$&&) = delete;
  $model.className$& operator=(const $model.className$&) = delete;
  $model.className$& operator=($model.className$&&) = delete;

$endif$
$if (model.templateArguments)$
 private:
  $ model.erasedTemplateArguments
    : {tArg | using $tArg.key$ = $boundTemplateType(tArg.value, "style=type")$;}
    ; anchor, separator = "\n"$

$endif$
$if (model.enum)$
 public:
  using enum_t = ::java::_static_accessor<$tagType(model)$>::enum_t;

$endif$

 public:
  $if (!model.enum)$
  $if (!model.hasDefaultConstructor)$$model.className$() = default;$endif$
  $model.className$(const $model.className$&) = delete;
  $model.className$($model.className$&&) = delete;
  JSER_INLINE $model.className$& operator=(const $model.className$&) = default;
  JSER_INLINE $model.className$& operator=($model.className$&&) = default;
  $endif$
  ~$model.className$() noexcept override$if (model.interface || model.abstract)$ = 0$endif$;

  // XXX constructors that take arguments.

  $ classMembers(model, false); anchor$
$if(model.fields)$

  // fields
  $model.fields:{f|$if (f.docString)$$renderDocString(f.docString)$$"\n"$$endif$$f.visibility$: $field(f)$;}; anchor, separator = "\n"$
$endif$
};
>>


accessorImpl(model) ::= <<
$model.fields:{f|$fieldAccessors(model, f, true)$}; separator = "\n"$

$accessorClassMembers(model, true)$

$staticAccessorClassMembers(model, true)$
>>


accessorImplSrc(model) ::= <<
$if (model.enum)$$accessorEnumToString(model, true)$$endif$
>>


accessorEnumToString(model, doImplement) ::= <%
$function(
    name="to_string",
    doImplement=doImplement,
    noexcept="noexcept",
    return="std::string_view",
    argumentTypes=[{::java::_static_accessor$templateArgs([tagType(model)], true)$::enum_t}],
    argumentNames=["enum_value"],
    body={$accessorEnumToStringBody(model)$})$
%>


accessorEnumToStringBody(model) ::= <<
using enum_t = ::java::_static_accessor$templateArgs([tagType(model)], true)$::enum_t;
using namespace std::string_view_literals;

switch (enum_value) {
$ model.enumValues
  : { v |
case enum_t::$v.remappedName$:
  return $u8StringView(v.name)$;$\\$
    }
  ; anchor, separator = "\n"$
}
>>


classImpl(model) ::= <<
$model.className$::~$model.className$() noexcept = default;

$ classMembers(model, true)$
>>


classMembers(model, doImplement) ::= <<
$ [model.classNonMemberFunctions, model.classMemberFunctions]
  : {m | $if (!doImplement || !m.pureVirtual || m.destructorMethod)$$\\$
         $if (!doImplement)$$m.visibility$:$"\n"$$endif$$\\$
         $function(
              name=m.name,
              doImplement=doImplement,
              return=m.returnType,
              containingClass=model.className,
              body=m.body,
              docString=m.docString,
              argumentNames=m.argumentNames,
              argumentTypes=m.argumentTypes,
              initializers=m.initializers,
              virtual=m.virtual,
              pureVirtual=m.pureVirtual,
              override=m.override,
              inline=m.inline,
              const=m.const,
              static=m.static,
              noexcept=m.noexcept,
              final=m.final
            )$$\\$
         $endif$}
  ; separator = "\n\n"$
>>


accessorClassMembers(model, doImplement) ::= <<
$ model.accessorMethods
  : {m | $function(
              name=m.name,
              doImplement=doImplement,
              return=m.returnType,
              body={return $if (m.returnType.unresolvedTemplateNames)$::java::cast<$boundTemplateType(m.returnType, "style=type, class=return")$>($endif$this->template ref_<$erasedType(model)$>().$m.name$($m.argumentNames:{name | ::std::move($name$)}; anchor, wrap, separator = ", "$)$if (m.returnType.unresolvedTemplateNames)$)$endif$;},
              docString=m.docString,
              argumentNames=m.argumentNames,
              argumentTypes=m.argumentTypes,
              containingClass="_accessor",
              containingClassTemplateArguments=["Base_", model.templateArgumentNames],
              containingClassTemplateArgumentsImpl=["Base_", tagType(model), model.templateArgumentNames],
              inline="JSER_INLINE",
              const=m.const,
              noexcept=m.noexcept,
              static=m.static
            )$}
  ; anchor, separator = "\n\n"$
>>


staticAccessorClassMembers(model, doImplement) ::= <<
$ model.staticAccessorMethods
  : {m | $function(
              name=m.name,
              doImplement=doImplement,
              return=m.returnType,
              body={return $if (m.returnType.unresolvedTemplateNames)$::java::cast<$boundTemplateType(m.returnType, "style=type, class=return")$>($endif$$erasedType(model)$::$m.name$($m.argumentNames:{name | ::std::move($name$)}; anchor, wrap, separator = ", "$)$if (m.returnType.unresolvedTemplateNames)$)$endif$;},
              docString=m.docString,
              argumentNames=m.argumentNames,
              argumentTypes=m.argumentTypes,
              containingClass="_static_accessor",
              containingClassTemplateArguments=[model.templateArgumentNames],
              containingClassTemplateArgumentsImpl=[tagType(model), model.templateArgumentNames],
              inline="JSER_INLINE",
              const=m.const,
              noexcept=m.noexcept,
              static=m.static
            )$}
  ; anchor, separator = "\n\n"$
>>


field(f) ::= <%
$boundTemplateType(f.fieldType, {style=type, class=field, $if (f.final)$final$endif$})$
$" "$
$f.name$
$if (f.default)${ $f.default; anchor$ }$endif$
%>


fieldAccessors(model, f, doImplement) ::= <%
$if (f.getterFn)$$fieldGetter(model, f, doImplement)$$endif$
$if (f.getterFn && f.setterFn)$$"\n"$$endif$
$if (f.setterFn)$$fieldSetter(model, f, doImplement)$$endif$
%>


fieldGetter(model, f, doImplement) ::= <%
$function(
    name=f.name,
    doImplement=doImplement,
    return=f.varType,
    body={$fieldGetterBody(model, f)$},
    containingClass="_accessor",
    containingClassTemplateArguments=["Base_", model.templateArgumentNames],
    containingClassTemplateArgumentsImpl=["Base_", tagType(model), model.templateArgumentNames],
    inline="JSER_INLINE",
    const=true
    )$
%>


fieldSetter(model, f, doImplement) ::= <%
$function(
    name=f.name,
    doImplement=doImplement,
    return=f.varType,
    argumentTypes=[f.varType],
    argumentNames=[{$f.name$}],
    body={$fieldSetterBody(model, f)$},
    containingClass="_accessor",
    containingClassTemplateArguments=["Base_", model.templateArgumentNames],
    containingClassTemplateArgumentsImpl=["Base_", tagType(model), model.templateArgumentNames],
    inline="JSER_INLINE"
    )$
%>


fieldGetterBody(model, f) ::= <<
return this->template ref_<typename $tagType(model)$::erased_type>().$f.name$;
>>


fieldSetterBody(model, f) ::= <<
return ::std::exchange(this->template ref_<typename $tagType(model)$::erased_type>().$f.name$, std::move($f.name$));
>>


classInheritance(model) ::= <%
$if (strip([model.superClass, model.interfaces]))$
: $ strip([model.superClass, model.interfaces])
    : {t|$classInheritTemplateClassRenderer(t.type)$}
    ; anchor, separator = ",\n"
  $
$elseif (!model.interface)$
$! Special consideration for java.lang.Object !$
: $["public ::cycle_ptr::cycle_base", "public virtual ::java::object_intf"]; anchor, separator = ",\n"$
$else$
$! Interfaces need to have ::java::object_intf as a base, so if they don't
 ! derive from an interface, declare the interface now.
 !$
: public virtual ::java::object_intf
$endif$
%>


accessorInheritance(model, base) ::= <%
$if (strip([model.superClass, model.interfaces]))$
: $ strip([model.superClass, model.interfaces]): {t|public virtual $boundTemplateType(t, {accessor, base=$base$, style=type})$}; anchor, separator=",\n"$
$else$
: public virtual $base$
$endif$
%>


classInheritTemplateClassRenderer(model) ::= <%
$if (model.interface)$public virtual$else$public$endif$ ::$["java", "_erased", model.namespace, model.className]; separator = "::"$
%>
