accessor(cdef) ::= <<
template<$["Base_", cdef.templateArguments]:{x|typename $x$}; separator = ", "$>
class _accessor<$["Base_", cdef.tagName, cdef.templateArguments]; separator = ", "$>
: public virtual Base_
{
 protected:
  JSER_INLINE _accessor() = default;
  JSER_INLINE _accessor(const _accessor&) = default;
  JSER_INLINE _accessor(_accessor&&) = default;
  JSER_INLINE _accessor& operator=(const _accessor&) = default;
  JSER_INLINE _accessor& operator=(_accessor&&) = default;
  JSER_INLINE ~_accessor() = default;

 public:
  // XXX field and method forwarders.
};
>>

class(cdef) ::= <<
class $cdef.className$
$classInheritance(cdef.model)$
{
$if (cdef.model.enum)$
  $cdef.className$() = delete; // Enum types are not default constructible.
  $cdef.className$(const $cdef.className$&) = delete;
  $cdef.className$($cdef.className$&&) = delete;
  $cdef.className$& operator=(const $cdef.className$&) = delete;
  $cdef.className$& operator=($cdef.className$&&) = delete;

 public:
  /**
   * \brief Raw enum constants for $[cdef.namespace, cdef.className]; separator = "."$
   * \note Enums start with upper case, followed by lower case, to avoid name clashes with defines.
   */
  enum class enum_t {
    $cdef.model.enumValues:{kv|$kv.remappedName$}; anchor, separator = ",\n"$
  };

 private:
  $cdef.className$(enum_t enum_value);
$endif$

 public:
  $if (!cdef.model.enum)$
  $cdef.className$();
  $cdef.className$(const $cdef.className$&);
  $cdef.className$($cdef.className$&&);
  JSER_INLINE $cdef.className$& operator=(const $cdef.className$&) = default;
  JSER_INLINE $cdef.className$& operator=($cdef.className$&&) = default;
  $endif$
  ~$cdef.className$() noexcept override$if (cdef.model.interface || cdef.model.abstract)$ = 0$endif$;

  // XXX constructors that take arguments.

  // XXX methods
  // XXX field accessors
  // XXX fields
};
$if (cdef.model.enum)$

auto to_string($cdef.className$::enum_t enum_value) noexcept -> std::string_view;
$endif$
>>

classImpl(cdef) ::= <<
$if (!cdef.model.enum)$
$cdef.className$::$cdef.className$() = default;
$cdef.className$::$cdef.className$(const $cdef.className$&) = default;
$cdef.className$::$cdef.className$($cdef.className$&&) = default;
$endif$
$cdef.className$::~$cdef.className$() noexcept = default;

$if (cdef.model.enum)$
auto to_string($cdef.className$::enum_t enum_value) noexcept
-> std::string_view {
  using namespace std::string_view_literals;

  switch (enum_value) {
  $cdef.model.enumValues
  : { v |
case $cdef.className$::enum_t::$v.remappedName$:
  return $u8StringView(v.name)$;$\\$
    }
  ; anchor, separator = "\n"$
  }
}
$endif$
>>

classInheritance(model) ::= <%
$if (strip([model.superClass, model.interfaces]))$
: $ strip([model.superClass, model.interfaces])
    : {t|$template(
            t=t,
            classRenderer={$classInheritTemplateClassRenderer(t.type)$},
            varRenderer={/* Can't inherit from 'var' */},
            arrayRenderer={/* Can't inherit from 'array' */},
            anyRenderer={/* Can't inherit from 'any' */}
          )$}
    ; anchor, separator = ",\n"
  $
$elseif (!model.isInterface)$
$! Special consideration for java.lang.Object !$
: $["public ::cycle_ptr::cycle_base", "public virtual ::java::object_intf"]; anchor, separator = ",\n"$
$else$
$! Interfaces need to have ::java::object_intf as a base, so if they don't
 ! derive from an interface, declare the interface now.
 !$
: public virtual ::java::object_intf
$endif$
%>

classInheritTemplateClassRenderer(model) ::= <%
$if (model.interface)$public virtual$else$public$endif$ ::$["java", "_erased", model.namespace, model.simpleName]; separator = "::"$
%>

template(t, classRenderer, varRenderer, arrayRenderer, anyRenderer) ::= <%
$(t.templateStyle)(classRenderer, varRenderer, arrayRenderer, anyRenderer)$
%>

templateClass(classRenderer, varRenderer, arrayRenderer, anyRenderer) ::= <%$classRenderer$%>
templateVar(classRenderer, varRenderer, arrayRenderer, anyRenderer) ::= <%$varRenderer$%>
templateArray(classRenderer, varRenderer, arrayRenderer, anyRenderer) ::= <%$arrayRenderer$%>
templateAny(classRenderer, varRenderer, arrayRenderer, anyRenderer) ::= <%$anyRenderer$%>
