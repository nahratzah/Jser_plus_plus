accessor(cdef) ::= <<
$templateLine(cdef.templateArguments, true)$
class _static_accessor$templateArgs([cdef.tagName, cdef.templateArguments], true)$ {
 protected:
  JSER_INLINE _static_accessor() = default;
  JSER_INLINE _static_accessor(const _static_accessor&) = default;
  JSER_INLINE _static_accessor(_static_accessor&&) = default;
  JSER_INLINE _static_accessor& operator=(const _static_accessor&) = default;
  JSER_INLINE _static_accessor& operator=(_static_accessor&&) = default;
  JSER_INLINE ~_static_accessor() = default;

 public:
$if (cdef.model.enum)$
  /**
   * \brief Raw enum constants for $[cdef.namespace, cdef.className]; separator = "."$
   * \note Enums start with upper case, followed by lower case, to avoid name clashes with defines.
   */
  enum class enum_t {
    $cdef.model.enumValues:{kv|$kv.remappedName$}; anchor, separator = ",\n"$
  };

  // Enum constants.
  $cdef.model.enumValues:{kv | $accessorEnumConstantMethodDeclaration(cdef, kv)$}; anchor, separator = "\n"$
$endif$
};

$templateLine(["Base_", cdef.templateArguments], true)$
class _accessor$templateArgs(["Base_", cdef.tagName, cdef.templateArguments], true)$
$accessorInheritance(cdef.model, "Base_")$
{
 protected:
  JSER_INLINE _accessor() = default;
  JSER_INLINE _accessor(const _accessor&) = default;
  JSER_INLINE _accessor(_accessor&&) = default;
  _accessor& operator=(const _accessor&) = delete;
  _accessor& operator=(_accessor&&) = delete;
  JSER_INLINE ~_accessor() = default;

 public:
$if (cdef.model.fields)$
  // field accessors
  $cdef.model.fields:{f|$fieldAccessors(cdef, f, false)$}; anchor, separator = "\n"$
$endif$

#if 0
  $cdef.model.classMembers: {m | $m$$"\n"$$if (m.body)$$m.body$$endif$}; anchor, separator = "\n\n"$
#endif
};
$if (cdef.model.enum)$

$accessorEnumToString(cdef, false)$
$endif$
>>


class(cdef) ::= <<
class $cdef.className$$if (cdef.model.final)$ final$endif$
$classInheritance(cdef.model)$
{
$if (cdef.model.enum)$
  $cdef.className$() = delete; // Enum types are not default constructible.
  $cdef.className$(const $cdef.className$&) = delete;
  $cdef.className$($cdef.className$&&) = delete;
  $cdef.className$& operator=(const $cdef.className$&) = delete;
  $cdef.className$& operator=($cdef.className$&&) = delete;

 public:
  using enum_t = ::java::_static_accessor<$cdef.tagName$>::enum_t;

  $cdef.model.enumValues:{kv| $classEnumConstantMethod(cdef, kv, false)$}; anchor, separator = "\n"$

  // We don't want this to be public, but without it, we're having a hard time
  // instantiating the enum class.
  JSER_INLINE $cdef.className$(enum_t enum_value) : value(enum_value) {}
$endif$

 public:
  $if (!cdef.model.enum)$
  $cdef.className$();
  $cdef.className$(const $cdef.className$&);
  $cdef.className$($cdef.className$&&);
  JSER_INLINE $cdef.className$& operator=(const $cdef.className$&) = default;
  JSER_INLINE $cdef.className$& operator=($cdef.className$&&) = default;
  $endif$
  ~$cdef.className$() noexcept override$if (cdef.model.interface || cdef.model.abstract)$ = 0$endif$;

  // XXX constructors that take arguments.
$if (cdef.model.classMembers)$

  // methods
#if 0
  $ cdef.model.classMembers
    : {m | $function(
                name=m.name,
                doImplement=true,
                return={::java::return_t<$m.returnType; format="style=type, class=return"$>},
                body=m.body,
                argumentNames=m.argumentNames,
                argumentTypes=m.argumentTypes:{a|$boundTemplateType(a, "style=type, class=param")$}
              )$}
    ; anchor, separator = "\n\n"$
#endif
$endif$
$if(cdef.model.fields)$

  // fields
  $cdef.model.fields:{f|$if (f.docString)$$renderDocString(f.docString)$$"\n"$$endif$$f.visibility$: $field(f)$;}; anchor, separator = "\n"$
$endif$
$if (cdef.model.enum)$

 public:
  ///\brief Value for the enumerator type.
  const enum_t value;
$endif$
};
>>


accessorImpl(cdefs) ::= <<
$if (cdef.model.enum)$
$cdef.model.enumValues:{kv | $accessorEnumConstantMethod(cdef, kv)$}; anchor, separator = "\n"$
$endif$

$cdef.model.fields:{f|$fieldAccessors(cdef, f, true)$}; separator = "\n"$
>>


accessorImplSrc(cdef) ::= <<
$if (cdef.model.enum)$$accessorEnumToString(cdef, true)$$endif$
>>


accessorEnumToString(cdef, doImplement) ::= <%
$function(
    name="to_string",
    doImplement=doImplement,
    noexcept="noexcept",
    return="std::string_view",
    argumentTypes=[{::java::_static_accessor$templateArgs([cdef.tagName], true)$::enum_t}],
    argumentNames=["enum_value"],
    body={$accessorEnumToStringBody(cdef)$})$
%>


accessorEnumToStringBody(cdef) ::= <<
using enum_t = ::java::_static_accessor$templateArgs([cdef.tagName], true)$::enum_t;
using namespace std::string_view_literals;

switch (enum_value) {
$ cdef.model.enumValues
  : { v |
case enum_t::$v.remappedName$:
  return $u8StringView(v.name)$;$\\$
    }
  ; anchor, separator = "\n"$
}
>>


classImpl(cdef) ::= <<
$if (!cdef.model.enum)$
$cdef.className$::$cdef.className$() = default;
$cdef.className$::$cdef.className$(const $cdef.className$&) = default;
$cdef.className$::$cdef.className$($cdef.className$&&) = default;
$endif$
$cdef.className$::~$cdef.className$() noexcept = default;

$cdef.model.enumValues:{ kv | $classEnumConstantMethod(cdef, kv, true)$}; separator = "\n"$
>>


field(f) ::= <%
$boundTemplateType(f.varType, "style=type, class=field")$
$" "$
$f.name$
%>


fieldAccessors(cdef, f, doImplement) ::= <%
$if (f.getterFn)$$fieldGetter(cdef, f, doImplement)$$endif$
$if (f.setterFn)$$fieldSetter(cdef, f, doImplement)$$endif$
%>


fieldGetter(cdef, f, doImplement) ::= <%
$function(
    name=f.name,
    doImplement=doImplement,
    return={$boundTemplateType(f.varType, "style=type, class=return")$},
    body={$fieldGetterBody(cdef, f)$},
    containingClass="_accessor",
    containingClassTemplateArguments=["Base_", cdef.templateArguments],
    containingClassTemplateArgumentsImpl=["Base_", cdef.tagName, cdef.templateArguments],
    inline="JSER_INLINE",
    const=true
    )$
%>


fieldSetter(cdef, f, doImplement) ::= <%
$function(
    name=f.name,
    doImplement=doImplement,
    return={$boundTemplateType(f.varType, "style=type, class=return")$},
    argumentTypes=[{$boundTemplateType(f.varType, "style=type, class=param")$}],
    argumentNames=["value"],
    body={$fieldSetterBody(cdef, f)$},
    containingClass="_accessor",
    containingClassTemplateArguments=["Base_", cdef.templateArguments],
    containingClassTemplateArgumentsImpl=["Base_", cdef.tagName, cdef.templateArguments],
    inline="JSER_INLINE"
    )$
%>


fieldGetterBody(cdef, f) ::= <<
return this->template ref_<typename $cdef.tagName$::erased_type>().$f.name$;
>>


fieldSetterBody(cdef, f) ::= <<
$if (f.varType.primitive)$
return ::std::exchange(this->template ref_<typename $cdef.tagName$::erased_type>().$f.name$, value);
$else$
$boundTemplateType(f.varType, "style=type, class=return")$ result = ::std::move(this->template ref_<typename $cdef.tagName$::erased_type>().$f.name$);
this->template ref_<typename $cdef.tagName$::erased_type>().$f.name$ = ::std::move(value);
return result;
$endif$
>>


classInheritance(model) ::= <%
$if (strip([model.superClass, model.interfaces]))$
: $ strip([model.superClass, model.interfaces])
    : {t|$classInheritTemplateClassRenderer(t.type)$}
    ; anchor, separator = ",\n"
  $
$elseif (!model.isInterface)$
$! Special consideration for java.lang.Object !$
: $["public ::cycle_ptr::cycle_base", "public virtual ::java::object_intf"]; anchor, separator = ",\n"$
$else$
$! Interfaces need to have ::java::object_intf as a base, so if they don't
 ! derive from an interface, declare the interface now.
 !$
: public virtual ::java::object_intf
$endif$
%>


accessorInheritance(model, base) ::= <%
$if (strip([model.superClass, model.interfaces]))$
: $ strip([model.superClass, model.interfaces]): {t|public virtual $boundTemplateType(t, {accessor, base=$base$, style=type})$}; anchor, separator=",\n"$
$else$
: public virtual $base$
$endif$
%>


accessorEnumConstantMethodDeclaration(cdef, kv) ::= <<
///\brief Enum constant $kv.name$.
static auto $kv.remappedName$()
-> ::$[cdef.namespace, cdef.className]; separator = "::"$;
>>


accessorEnumConstantMethod(cdef, kv) ::= <<
$if (cdef.templateArguments)$
template<$[cdef.templateArguments]:{x|typename $x$}; separator = ", "$>
$endif$
JSER_INLINE auto _static_accessor<$[cdef.tagName, cdef.templateArguments]; separator = ", "$>::$kv.remappedName$()
-> ::$[cdef.namespace, cdef.className]; separator = "::"$ {
  return ::$[cdef.namespace, cdef.className]; separator = "::"$(
      ::java::_direct(),
      $["java", "_erased", cdef.namespace, cdef.className, kv.remappedName]; separator = "::"$());
}
>>


classEnumConstantMethod(cdef, kv, doImplement) ::= <%
$function(
    name=kv.remappedName,
    docString={\brief Enum constant $kv.name$.$\n$\returns An instance of $[cdef.namespace, cdef.className]; separator = "::"$.},
    doImplement=doImplement,
    return={cycle_ptr::cycle_gptr<$cdef.className$>},
    containingClass=cdef.className,
    body={$classEnumConstantMethodBody(cdef, kv)$},
    static=true
    )$
%>


classEnumConstantMethodBody(cdef, kv) ::= <<
static const cycle_ptr::cycle_gptr<$cdef.className$> impl =
    cycle_ptr::make_cycle<$cdef.className$>($cdef.className$::enum_t::$kv.remappedName$);
return impl;
>>


classInheritTemplateClassRenderer(model) ::= <%
$if (model.interface)$public virtual$else$public$endif$ ::$["java", "_erased", model.namespace, model.simpleName]; separator = "::"$
%>
